首先这题要先通过 passcode 的校验才能继续，而 passcode 显然不是我们所能直接猜出来。

仔细观察判断部分内存分布可发现，memcmp 的结果正在存在我们输入的 passcode 后面，而输入不会补 '\0'，于是我们可以直接在报错中拽出比较结果（有时候还能拽出 passcode 的长度为 0xf）。
本来以为这样直接二分一下很轻松，然而跑的时候却发现了问题，即比较结果并非是 -1, 0, 1 中的一个，而可以是任意正、负数，并且经常会出现最低位为 0，顿时觉得好坑。

然后进入半手动模式，仔细观察比较结果发现，在比较的时候：

* 如果第一位不对，返回结果正好会是两个 char 的差；

* 如果第二位不对，返回结果最低位会是 0，而如果正确，则不会是 0；

* 第三、五、七位同第一位，第四、六位同第二位

然后跑到第八位时又出现问题，所有返回最低位都是 0，于是乎，改成第 8、9 位一起跑，然后会发现其中有一个返回末尾不是 0，即正确的情况。

然后同时跑两位数量还是有点大的，然后服务器刚开始的时候那个效率真心低，要跑好久好久，所以我是大胆猜测只有数字字母。
不过后来服务器程序更新加速后跑的飞快，一下下就能跑出来。

然后接下来继续跑，发现奇偶的规律反过来了，即：

* 第十、十二、十四位同第一位

* 第十一、十三、十五位同第二位

然后最终跑出 passcode 为 `dGhpc3Bhc3Njb2R`。

拿到 passcode 后，后面是一个明显裸栈溢出，但是加入了一个限制，即不能是 `0x60****` 和 `0x40****` 的形式，这正好是程序的各种段的地址。
于是乎，这样等于限制了不能使用程序本身的 gadget，同时也不能用任何程序本身的地址当参数。

被限制之后，接下来想的是覆盖掉 rbp 的位置，从而实现换栈，因为程序起的命令行参数是我们指定的，所以可以控制栈上内容，然后在栈中写入 ROP 链完成攻击。
但是，这样必须要求泄漏栈地址，而苦于找不到泄漏的办法，于是卡死。同时由于当时题目数量远大于做题人数，只得放弃。接下来怎么做只能啥时候有空再看看了。
