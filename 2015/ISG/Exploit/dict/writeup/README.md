虽然没能赶上结束前写完 exp，不过也附上了，顺带吐槽，祭奠下 `(>_>)`。

作为一个之前只写过一次堆溢出的人来说，看到这题的时候，心是碎的……

首先是整数溢出带来随意改写堆上内容，又有指向堆的指针，构造假 chunk 修改指针很好办。

然后鉴于早已忘记具体假 chunk 怎么构造的细节来着，翻出上次那题，发现当时太赶，也木有注释，写的玩意现在简直看不懂，然后 writeup 也是带过，木有写具体构造方法，然后上次看的那篇 writeup 忘了是啥了，死命的也找不到，心中千万只草泥马在奔腾。

最后搜的时候发现上次 0ctf freenote 的 writeup 看了下，加上一点印象与 YY，终于搞定，成功改调 bss 中指针，修改过后得到类似结构：

```
0x804a0c0:    0x00000000    0x080cb008    0x00000004    0x080cb090
0x804a0d0:    0x00000004    0x0804a0c8    0x00000004    0x080cb1a0
```

0x804a0d8 处的指针我们成功改成 0x0804a0c8，然后这时候想要通过这个指针来改 bss，进而进一步改 got 表必须要 realloc 这个指针。
想要 realloc 之后指针不变容易，只要新大小不大于旧大小即可，然后想要 realloc 的时候，发现会检查当前 chunk 大小是否为合法大小。
也就是这里 0x804a0c4 位置上那个数，这里由于是 malloc 出来的指针，所以大小很难控制，各种乱 malloc 也搞不出能满足条件的值。
于是成功卡死，偏偏第一天就剩这么一个 pwn，然后除开完全不会的 web，以及一时脑洞不处理的 misc，似乎别的题都搞定了。
*于是一种想砍出题人的冲动在心中翻滚！！！*

第二天突然放一堆题，然后这次鉴于各种时间冲突木有什么人（坑爹的 XDCTF），各种题要做就果断把这题放着了。
结果 pwn300 再度卡死，好不容易蛋疼搞出了那个 passcode，后面一连串拿 shell 的方法都想好了，就差随便来个啥信息泄漏就好，结果就是想不出来……
**放开那个出题人，让我来砍！！！**

最后晚上的时候，似乎这次除了 web 和没做出的 pwn，真是一题不剩（剩的 iOS 给队友看去了）。
然后鉴于这题过的人多点，继续死磕这题……
最后差不多两小时的时候，突然想到似乎听说过 fastbin 也是可以搞的，可能搞 fastbin 效果不太一样，就能继续了……
于是赶快继续看 libc 源代码中之前无视了的 fastbin 相关部分，发现就个单链表，于是 YY unlink，一试果然成功改了个指针为任意值。

```
0x804a0c0:    0x00000000    0x080cb008    0x00000029    0x41414141
```

但是由于 unlink 前检查了 chunk 的大小，这里是 0x29，所以说我们无法直接改 got 表中的指针。
不过至少有进步，改完信息泄漏有了，有希望，继续 YY。

由于这里 fastbin 用的时候，我们可以直接改掉一个 chunk 中内容大小的内存，这里也就是 0x20，那我们完全可以构造一个堆头，过掉之前那个 realloc 中当前 chunk 大小的检查。
然而，过掉后发现，它还会检查下一个 chunk 大小，而下一个 chunk 的位置是当前 chunk 加纪录的大小，然后企图通过设当前大小 0x10 使得下一个块仍在我们能修改的范围内。
然后检查过掉后，发现会由于新申请的空间大小大于 0x10，而触发 free 挂彩，而我们绝对无法让新申请的大小小于 0x20。
而要想把当前大小增大，就只能将大小设置成以 4 对齐，然后又会触发未对齐的检查。

然后企图将 dict 中的单词数由 1 改到 2，从而修改更多内存。
然而这样一个 chunk 的大小会变成 0x48，似乎是由于超过了 fastbin 最大大小（似乎是 64），改完程序直接跪。
再次挂彩，诈尸起来继续上路……

一次 fastbin 不行，那能不能尝试弄两次从而改两个块。
直接重复上次的操作又莫名其妙挂了，目测又撞上某要命的检查。
然后仔细想想 fastbin 的结构，一个内部变量存了当前单链表头，每次 free 就加到链表头，malloc 就从链表头取。
我们利用的时候，是通过 free，然后修改那个 free 的块，再 malloc 的时候，那个链表头就会变成我们设定的任意值。
然后当我们再 malloc 的时候，链表头就会变成我们设定的那个指针处的第三个 word 的值，也就是之前那个结构中 0x41414141 那里被改之前的值。
很显然这个指针指向的地方我们也是可控的，那我们只要把里面的内容设置好，我们就可以再次 free，把链表头指针改成一个任意值。

然后当我们 free 的时候，又莫名跪了，滚回去看 libc 源代码中从链表中取出指针之后的检查。
发现检查了分配出来的那块内存的是否确实是 free 状态的，而这个信息是存在后面一个堆块中的，并且在我们第一次 free 的时候，分配出来的也是这个块，所以查出来这个块肯定是已分配状态的。
我听到了心碎的声音，还有多少坑要踩……

为了保持是非 free 状态，我们自己去改后面那个块会比较蛋疼，稍不小心，某个操作就又触发某个检查又会跪，毕竟我们已经把堆搞的各种乱了。
然后想了想，最好的办法，就是在最开始多 free 几个块，然后这次分配的时候，给一个确实就是 free 的块就好了。

这样完成之后，链表头又被改成了我们想要的任意值，然后再 free 一次就好，注意不要让当前块大小的检查挂了就好。
此时可以得到堆结构如下：

```
0x804a0c0:    0x00000001    0x080cb008    0x00000029    0x41414141
0x804a0d0:    0x00000028    0x00000029    0x07fffffb    0x0804a0d8
0x804a0e0:    0x00000000    0x080cb0a8    0x00000029    0x41414141
0x804a0f0:    0x00000001    0x0804a038    0x00000028    0x00000029
0x804a100:    0x00000000    0x080cb600    0x00000001    0x0804a0ec
```

此时 view 0x804a0f8 处那个指针可以看到 atoi 的 GOT 表，用 libc.so 计算 system 的地址。
然后通过 realloc 0x804a0dc 处那个指针即可修改 atoi 的 GOT 表为 system（`0x0804a0d8 + 0x07fffffb * 32 = 0x10804a038 <=> elf.got['atoi'] = 0x0804a038`）。
接下来输入选项的时候输入 `/bin/sh` 即可拿到 shell，泪奔 `(T_T)`。

话说因为没赶上最后时限前搞定，所以不知道用 pwn100 的 libc 行不行，不过现在最后那一步那几个指针稍微调整下，就可以任意次数读写了，所以不用 libc 应该也可以找出来 system 的地址，不过也懒得搞了，反正没线上环境了。

--------------------------------------------------------------------------------

看完 flappy pig 的 writeup，真是一种想一头撞死的冲动在蔓延。
realloc 失败之后竟然可以直接写到那种大地址，当时完全就没往这边想，一开始看到可以越界写就觉得肯定是搭配堆溢出了，从此走上一条不归路。

有了任意写之后，真的构造就跟玩似的了，随便改下指针就有任意读……

哎，说多了都是泪 (T_T)
