程序很明显的一个栈溢出，无栈cookie，又是32位，参数可直接控制，但是由于没给libc，无法根据泄漏got表计算system的地址。

但是由于程序可以无限次泄漏，且长度不限，即意味着我们完全有能力dump出整个内存，故而肯定可以直接在内存中找到system的地址，简单起见，可以直接使用pwntools中的DynELF。

由于DynELF只能查找库函数地址，故而，查找`/bin/sh`字符串比较麻烦，于是可以选择通过调用read读入到空闲地址。

比较坑的是，做的时候泄漏system地址后，调用system总是无效，但是调用write确能正常输出，在system下断点发现程序确实执行过去并且参数正确，死命的不知道哪里错了，最后在调用system之前，让程序跳到__start恢复栈重新开始程序就可以成功调用system。
