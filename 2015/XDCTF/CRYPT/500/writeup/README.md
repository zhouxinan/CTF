这题是道椭圆曲线，需要预测产生的下一个随机数，首先nistp256这条曲线是固定的，可以搜到相关的参数。通过观察getrand里面的操作，可知产生的随机数是Q*x在x轴上的值，而下一次使用的x是P*这次的x，因为服务器会返回第一次的随机数，Q以及d，P是曲线的基点是固定的，所以可以令返回的随机数所对应的椭圆曲线点在乘上d的逆元得到下一次使用的x，然后顺推得到下一次的随机数（generate_backdoor里甚至都求了逆元，这是提示么）。

然后怎么从x轴的值反推椭圆曲线的点我卡了快一个白天……

最后好像是搜椭圆曲线基点选取的时候找到了现成的算法，特殊情况下的离散对数问题，二次剩余之类虽然听过不过以前不太熟悉啊。

似乎服务器会等的时间比较久，于是懒得写程序直接用python命令行手动搞，以下是部分命令记录：

```python
a=0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc
b=0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b
p=a+3
p1=(p+1)/4
```

curve是曲线

P是基点，不要吐槽跟上面那个p长这么像

```python
>>> xi=57914131887997596536669874361124734441741601814101568455763547876867316798523
>>> t=(xi**3+a*xi+b)
>>> t1=t%p
>>> pow(t1,p1,p)
43331064576091791900838480679880237851600469995188036303750484440002321848367L

>>> d=9673497928745459324013728553516164787612436752039204660069136338836429731578
>>> Q=seccure.AffinePoint(3529261633757778563782558685806991416222128376163198390623944234947821868434,1227400874056650306347612046180653179066970966812566313338015124847638720935,curve)
>>> i0=seccure.AffinePoint(57914131887997596536669874361124734441741601814101568455763547876867316798523,43331064576091791900838480679880237851600469995188036303750484440002321848367,curve)
>>> e=gmpy.invert(gmpy.mpz(d),curve.order)>>> i1=i0*e
>>> Q*i1.x
<AffinePoint (2905397088598526610908372447023102363026764674296260395110813409314612564062, 6813252672640352463766524774630903620705840560787288153888638751744747727230) of secp256r1/nistp256>
```
