This challenge is really interesting.

We have the source code, so we do not need to reverse.

It's easily to find the buffer overflow.
However, the length of overflow is fixed.
We have to overwrite the return address of `check_password_correct` and the last two bytes of `require_auth`'s return address.

As the program is compile with PIE enable, once we fill the the return address of `check_password_correct` wrong, it will crash.
However, changing the last two bytes of `require_auth`'s return address is definitely the correct way.
As the last 24 bits will not be randomized according to the page size, we have a success rate of one sixteenth to get shell.

So what we need to find a `ret` in fixed address. After debug the program multiple times. I found a segment called `vsyscall`. It's executable and the adress seems fixed.
Search it in google, I confirm my conjecture.
Disassemble the segment, I simply find a `ret` at 0xffffffffff600009.

However, after I wrote the exp and try to run code at `0xffffffffff600009`, I got a segmentation fault.
It's really strange and incomprehensible.

After a while, my teammates find such description:

```
vsyscall is an obsolete method (replaced by vdso) to do vast system calls. Because it is part of the linux x86-64 ABI, it always has to be mapped to a static address by the kernel.
This means that in the case of a vulnerability (in some user program), an attacker making use of return oriented programming can rely on useful gadgets at a known address (bypassing ASLR.) Using the gadgets in vsyscall it is possible to get arbitrary code execution with only one trivial extra gadget (or in some cases none at all.) This is why recent kernels emulate the obsolete vsyscall ABI in-kernel. The emulation makes sure that an attacker can only call functions defined by the ABI, like gettimeofday(), and cannot, for example, directly jump to a syscall & ret gadget. Only calls to offsets defined in the ABI are allowed. In my opinion, backporting the new default behaviour of emulating vsyscall to LTS would increase the time / effort / skill needed for exploit writers to write a successful exploit somewhat, and make the resulting exploits less generic.
```

According to this, I try to jump to `0xffffffffff600000` instead of `0xffffffffff600009`.
Then after running for multiple times, I successful got the shell.

I really like this challenge thought it may be too easy for the ones who this tricky before.
