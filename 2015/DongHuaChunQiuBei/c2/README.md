# WriteUp

这题漏洞本身并不难，但是由于程序不短，所以看起来比较麻烦，然后整个流程也是各种无语，没事就 sleep 一下，于是 patch 了一下方便调试的时候使用。

大概看了下程序骨干后会发现，程序一共有三种 pokemon，而三种的结构体定义类似，当各字段长度不一致，然后其中还有一个函数指针。
于是大概就可以猜到程序的目的，应该是通过把三种类型弄混之后，从而可以覆盖函数指针实现程序流的控制。

然后仔细查看程序会发现，在抓 pokemon 的过程中，当 pokemon 数量已满，替换的时候程序并没有修改存储的 pokemon 的类型，可以利用。

利用的过程比较繁琐，需要抓大量 pokemon：

1. 首先抓取足量类型 2 的 pokemon；

1. 在第 13 次探险中，会遇到类型 1 的 pokemon，攻击到可捕捉血量后，捕捉，替换掉之前捕捉的一只类型 2 的 pokemon；

1. 修改 pokemon 的 artwork，由于其本身为类型 1，故实际长度过长，可覆盖到类型 2 的 pokemon 中的函数指针；

1. 第一次将函数指针覆盖为 printf 的 plt 表，利用格式化字符串泄漏 main 函数 return address，即泄漏出 libc 地址；

1. 再次修改 pokemon 的 artwork，将函数指针覆盖为计算得到的 system，拿 shell；

程序实现过程中需要注意交互的时候，要注意 read 的长度以及是否有 sleep 卡住，否则发太快容易被坑……

PS：这里的 libc 不是现场 libc，为写 EXP 时本地的 libc `(>_>)`
